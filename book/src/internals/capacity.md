# Capacity

All the queues and arrays internally used by the RTFM runtime are fixed in size and allocated in
`static` variables. The user directly controls the size of most of these data structures via the
`capacity` property of a task in the `app!` specification.

For example if the user specifies that task `a` has a `capacity` of 3 then the `app!` macro
generates the following code:

``` rust
mod a {
    const CAPACITY: usize = 3;

    static mut FREE_QUEUE: Queue<u8, U3> = Queue::new();

    static mut PAYLOADS: [i32; CAPACITY] = unsafe { uninitialized() };
}

// generated by `app!`
fn main() {
    unsafe {
        // ..

        // initialize the `FREE_QUEUE` of each task
        for index in 0..a::CAPACITY {
            a::FREE_QUEUE.enqueue_unchecked(index as u8);
        }

        // ..

        // call user provided `init`
        init(init::Context());

        // ..
    }
}
```

There is a choice to be made by the implementers of the runtime when it comes to the size (capacity)
of the ready queues.

Ready queues hold instances of tasks pending execution of potentially different types. However, for
each task we know the maximum number of instances that can be scheduled and pending execution; this
information is in the specification (`capacity`). If we choose the capacity of the ready queue to be
the sum of the max number of instances of each different task it can hold then we can eliminate the
possibility of it ever running out of capacity -- in the worst case scenario the ready queue will
become full. In the Cortex-M implementation of RTFM we chose this sum as the capacity of the ready
queues; this let us eliminate capacity checks when adding new tasks to the ready queue.
