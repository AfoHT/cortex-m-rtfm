# Reacting to events

RTFM main use case is building reactive systems: systems that respond to external stimuli. In RTFM,
tasks are the main mechanism to respond to *events*, or interrupt sources.

Below is shown an RTFM program with a single *event* task:

``` rust
#![feature(proc_macro)]
#![no_std]

extern crate cortex_m_rtfm;

use cortex_m_rtfm::app;

app! {
    device: stm32f103xx,

    tasks: {
        exti0: {
            interrupt: EXTI0, // this interrupt corresponds to the user pressing a button
        },
    },
}

// omitted: init and idle

// the body of the `exti0` task
fn exti0(ctxt: exti0::Context) {
    // executed whenever a certain button is pressed

    println!("User pressed a button");
}
```

Here we have a task named `exti0` bound to the `EXTI0` interrupt source. The `exti0` task starts,
i.e. the `exti0` function is called, whenever the `EXTI0` interrupt fires. Interrupts are device
specific and come from the device crate, `stm32f103xx`. In this case the interrupt `EXTI0` is
triggered by a change in the logic level of a digital input pin. In this example said pin is
connected to a button; thus pressing the button triggers the `exti0` task.

Each task has access to a `Context`. The fields of this `Context` struct are:

``` rust
// generated by the `app!` macro
mod exti0 {
    pub struct Context {
        pub input: (),
        pub resources: Resources,
        pub tasks: Tasks,
        pub threshold: Threshold,
    }

    // ..
}
```

Event tasks map directly to device specific interrupts. The RTFM runtime will take care of both
*unmasking* those interrupts and setting their priorities in the NVIC *after* `init` ends and
*before* `idle` starts. Note that in most cases is necessary to also enable the interrupt in the
device specific peripheral to get the interrupt source to fire the event task.

The other consequence of tasks being interrupts is that tasks won't start until after `init`
ends -- because interrupts are disabled during `init`. That is if an event occurs during `init` the
corresponding task will be set as *pending* but it won't start until *after* `init` ends.
